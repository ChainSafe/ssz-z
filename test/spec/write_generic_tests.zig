const std = @import("std");
const spec_test_options = @import("spec_test_options");

pub fn main() !void {
    const allocator = std.heap.page_allocator;

    const out = try std.fs.cwd().createFile("test/spec/generic_tests.zig", .{});
    defer out.close();

    var writer = out.writer().any();

    try writer.writeAll(
        \\// This file is generated by write_general_tests.zig.
        \\// Do not commit changes by hand.
        \\
        \\const std = @import("std");
        \\const spec_test_options = @import("spec_test_options");
        \\const types = @import("generic_types.zig");
        \\const test_case = @import("test_case.zig");
        \\
        \\const generic_tests_dir_name = "general/tests/general/phase0/ssz_generic";
        \\const allocator = std.testing.allocator;
        \\
        \\
    );

    const generic_tests_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        "general",
        "tests",
        "general",
        "phase0",
        "ssz_generic",
    });
    defer allocator.free(generic_tests_dir_name);

    const generic_tests_dir = try std.fs.cwd().openDir(generic_tests_dir_name, .{ .iterate = true });
    var generic_tests_dir_it = generic_tests_dir.iterate();
    while (try generic_tests_dir_it.next()) |g_test_entry| {
        switch (g_test_entry.kind) {
            .directory => {},
            else => {
                continue;
            },
        }

        const test_dir_name = g_test_entry.name;
        // Skip progressive-related directories we don't support yet (but include basic_progressive_list)
        if (std.mem.eql(u8, test_dir_name, "progressive_bitlist") or
            std.mem.eql(u8, test_dir_name, "progressive_containers") or
            std.mem.eql(u8, test_dir_name, "compatible_unions"))
        {
            continue;
        }

        const valid_tests_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
            generic_tests_dir_name,
            test_dir_name,
            "valid",
        });
        defer allocator.free(valid_tests_dir_name);

        const valid_tests_dir = try std.fs.cwd().openDir(valid_tests_dir_name, .{ .iterate = true });
        var valid_tests_dir_it = valid_tests_dir.iterate();
        while (try valid_tests_dir_it.next()) |valid_test_entry| {
            switch (valid_test_entry.kind) {
                .directory => {},
                else => {
                    continue;
                },
            }

            const test_name = valid_test_entry.name;
            const type_name = getTypeName(test_dir_name, test_name);
            // Skip progressive container variants
            if (std.mem.eql(u8, type_name, "ProgressiveBitsStruct") or std.mem.eql(u8, type_name, "ProgressiveTestStruct")) {
                continue;
            }

            try writeValidTest(writer, test_name, test_dir_name, type_name);
        }

        const invalid_tests_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
            generic_tests_dir_name,
            test_dir_name,
            "invalid",
        });
        defer allocator.free(invalid_tests_dir_name);

        const invalid_tests_dir = try std.fs.cwd().openDir(invalid_tests_dir_name, .{ .iterate = true });
        var invalid_tests_dir_it = invalid_tests_dir.iterate();

        while (try invalid_tests_dir_it.next()) |invalid_test_entry| {
            switch (invalid_test_entry.kind) {
                .directory => {},
                else => {
                    continue;
                },
            }

            const test_name = invalid_test_entry.name;
            const type_name = getTypeName(test_dir_name, test_name);

            // Skip progressive container variants
            if (std.mem.eql(u8, type_name, "ProgressiveBitsStruct") or std.mem.eql(u8, type_name, "ProgressiveTestStruct")) {
                continue;
            }
            // // Skip progressive list invalid tests while feature stabilizes
            // if (std.mem.eql(u8, test_dir_name, "basic_progressive_list") or std.mem.startsWith(u8, type_name, "proglist_")) {
            //     continue;
            // }
            try writeInvalidTest(writer, test_name, test_dir_name, type_name);
        }
    }
}

fn getTypeName(test_dir_name: []const u8, test_name: []const u8) []const u8 {
    if (std.mem.eql(u8, test_dir_name, "boolean")) {
        return "boolean";
    } else if (std.mem.eql(u8, test_dir_name, "basic_vector")) {
        var split_it = std.mem.splitScalar(u8, test_name, '_');
        _ = split_it.next();
        _ = split_it.next();
        _ = split_it.next();
        return test_name[0 .. (split_it.index orelse (split_it.buffer.len + 1)) - 1];
    } else if (std.mem.eql(u8, test_dir_name, "basic_progressive_list")) {
        // Include the limit in the mapped type name, e.g. proglist_uint32_20
        var split_it = std.mem.splitScalar(u8, test_name, '_');
        _ = split_it.next(); // proglist
        _ = split_it.next(); // uintXX
        _ = split_it.next(); // limit
        return test_name[0 .. (split_it.index orelse (split_it.buffer.len + 1)) - 1];
    } else if (std.mem.eql(u8, test_dir_name, "containers")) {
        var split_it = std.mem.splitScalar(u8, test_name, '_');
        return split_it.first();
    } else {
        var split_it = std.mem.splitScalar(u8, test_name, '_');
        _ = split_it.next();
        _ = split_it.next();
        return test_name[0 .. (split_it.index orelse (split_it.buffer.len + 1)) - 1];
    }
}

/// Assumes the following global decls
/// - std, allocator, spec_test_options, generic_tests_dir_name, test_case, {tests_dir}, types.{type_name}
fn writeValidTest(
    writer: std.io.AnyWriter,
    test_name: []const u8,
    test_dir_name: []const u8,
    type_name: []const u8,
) !void {
    try writer.print(
        \\test "Valid - {s}" {{
        \\    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{{
        \\        spec_test_options.spec_test_out_dir,
        \\        spec_test_options.spec_test_version,
        \\        generic_tests_dir_name,
        \\        "{s}/valid/{s}",
        \\    }});
        \\    defer allocator.free(test_dir_name);
        \\
        \\    const test_dir = try std.fs.cwd().openDir(test_dir_name, .{{}});
        \\    try test_case.validTestCase(types.{s}, allocator, test_dir, "meta.yaml");
        \\}}
        \\
        \\
    ,
        .{
            test_name,
            test_dir_name,
            test_name,
            type_name,
        },
    );
}

/// Assumes the following global decls
/// - std, allocator, spec_test_options, generic_tests_dir_name, test_case, {tests_dir}, types.{type_name}
fn writeInvalidTest(
    writer: std.io.AnyWriter,
    test_name: []const u8,
    test_dir_name: []const u8,
    type_name: []const u8,
) !void {
    try writer.print(
        \\test "Invalid - {s}" {{
        \\    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{{
        \\        spec_test_options.spec_test_out_dir,
        \\        spec_test_options.spec_test_version,
        \\        generic_tests_dir_name,
        \\        "{s}",
        \\        "invalid",
        \\        "{s}"
        \\    }});
        \\    defer allocator.free(test_dir_name);
        \\
        \\    const test_dir = try std.fs.cwd().openDir(test_dir_name, .{{}});
        \\    try test_case.invalidTestCase(types.{s}, allocator, test_dir);
        \\}}
        \\
        \\
    ,
        .{
            test_name,
            test_dir_name,
            test_name,
            type_name,
        },
    );
}
